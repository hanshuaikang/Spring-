# 面向初学者的docker学习教程：基础篇

## 前言:

之前很早就对Docker有所耳闻，但是碍于时间(就是懒得学)的关系，就一直没有开始行动，直到最近这个学期课比较少，实在不知道该干啥了，算了，学习吧。所以就开始了我漫长Docker学习之旅。当然，写这篇笔记的时候，我对Docker已经大概有了一个初步的了解，所以就有了这个面向初学者的Docker学习笔记系列，为什么是初学者呢，因为我自认为我对Docker的了解依然是一个比较初级的阶段，所以更高级的内容怕说不明白，以至于误导了别人，写这系列的笔记主要初衷有两个，一来是为了对自己这个阶段所学的知识做一个全面的梳理和总结，二来顺便将这些知识用我风骚的写法做成笔记，帮助后面学习Docker的小伙伴更通俗易懂的去理解Docker相关的知识和概念，本篇文章作为基础篇第一篇，将围绕这三个问题来展开：

1. 什么是Docker？
2. 为什么是Docker？
3. Docker 具体解决了什么样的问题？

## 什么是docker?

Docker是基于Go语言实现的在2013年发布的云开源项目，它利用了围绕容器这个现有的计算概念，特别是在Linux世界中，这些原始概念被称为cgroups和命名空间。Docker的技术之所以独特是因为它专注于开发人员和系统操作员的需求，以将应用程序依赖项与基础架构分开。

Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。

一句话概括，Docker的出现解决了运行环境和配置环境不一致的情况，从而更方便的做持续集成并有助于整体发布。



## 为什么是Docker？

要了解这个问题，我们就需要了解在Docker之前的传统的虚拟机技术是怎样的，我相信大家都有使用过虚拟机软件在自己电脑上虚拟出另外的操作系统的经历，比如在win上通过vm安装一个linux系统，传统的虚拟机其实是一种带环境安装的解决方案，也就是说，我模拟的是一套完整的操作系统环境，这个系统依然是有它独立的内核，驱动等等。

如图所示：

![img](https://github.com/hanshuaikang/HanShu-Note/blob/master/Docker%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image/index.png?raw=true) 

对于虚拟机中运行的程序而言，由于虚拟机模拟了一整套系统的环境，那么在虚拟机中运行的应用程序是感知不到自己是在虚拟机中运行的，就像和在真实的操作系统中运行一样。

当然，看到这，很多人可能会觉得，这不是挺好的吗，的确，在需求不是很大，比如只需要额外开两三台虚拟机的时候，这种做法并没有什么明显的短板，但是，由于我们模拟的是一整套操作系统的环境，这就导致了什么问题呢，我们每开一个虚拟机都会额外占用很大一部分资源，尽管你可能两台虚拟机中的linux系统内核是一模一样的，这就造成了对资源的一个很大的浪费，同时呢，由于我们启动虚拟机的时候启动的是一整套操作系统，这就会导致启动变得非常的慢，可能需要几分钟，当然，几分钟并不是很长，可是如果有很多台虚拟机呢？可能当运维好不容易把所有虚拟机启动完成了，发现秒杀已经结束了，这对于很多大规模的应用来说是不能忍的，第三点，就是步骤非常繁琐，我们现在总结一下传统虚拟机最主要的三个缺点:

- 资源占用比较多
- 启动比较慢

- 步骤繁琐

当然，时代再进步，linux也不能看着这些问题放任不管啊，于是linux发展出了另外一项虚拟化技术，即linux容器技术。

linux容器技术是怎么一回事呢，这点和我们在实际开发中抽取公共逻辑的思路是类似的，之前不是开很多虚拟机内核什么的都一样造成资源浪费吗，那我这下把内核单独抽离出来，大家公用，**所以linux容器实际上运行的并不是一个完整的操作系统，而是通过进程对不同的容器进行了隔离，容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。**

如同所示：

![img](https://github.com/hanshuaikang/HanShu-Note/blob/master/Docker%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/image/index2.png?raw=true)

由于启动的时候，启动的并不是整套操作系统环境，仅仅是启动应用所需的环境就行了，启动速度自然就比传统的虚拟机快了很多，甚至说可以做到秒启动，同时又解决了资源浪费的问题，而Docker正是基于linux容器技术而衍生出来的开源项目，使其对于广大开发者来说更容易上手，降低了使用的门槛。



## Docker 具体解决了什么样的问题？

这个就要从很久很久以前说起了。

故事发生在9012年全球最伟大的互联网公司阿里奶奶次世代产品**免费版某宝**的上线前夕，程序员阿呆把自己多日以来**呕心沥血呼呼大睡上班摸鱼下班蹦迪**写的程序代码交付给了运维二呆，本以为自己将代码给了二呆就可以**满面春光如释重负迈着六亲不认的步伐深夜买醉瘫倒在灯红酒绿纸醉金迷的酒吧**，但是正当阿呆准备开始这崭新的生活的时候，二呆拦住了他：

阿呆，你这代码有问题吧，我怎么跑不起来？

阿呆：WTF ？我没听错吧，你竟然说我的代码有问题，呵呵，某人运维技术不行，还好意思说我菜？

二呆：我运维技术不行，我运维技术不行，你行你上啊，开玩笑，你代码写的没问题我能跑不起来？

阿呆：你睁大你的24k钛合金x眼看看，我电脑上是不是跑的好好的，是你运维技术不行，ok?

二呆：我&%￥%*&*,你代码没问题是吧，你代码没问题是吧，你来啊，有本事你跑起来，你要能跑起来我直播女装，臭弟弟。

阿呆：我今天就让你看看，我是怎么把它完美的部署上去的，你给我好好看着，知道吗？！

此时，阿呆的女朋友打来电话：阿呆，不是说好了一起去醉生梦死的吗？

阿呆：滚，现在没空搭理你。

注：以上皆为节目效果，大家请勿当真。

传统的开发中总是会出现这类开发环境和生产环境不一致的问题，而Docker的出现毫无疑问极大地简化了运维工程师的工作量，也大大降低了开发和运维之间撕逼的概率。大家这么来理解：

我们以搬家为例，传统的流程就可以看作是把所有家具一件一件地搬到新的地方，万一哪个家具的摆放位置没记清楚，就有可能导致新家运行不起来（？？什么鬼），而**Docker就很简单粗暴，Docker采取的方式就是把整套环境打包给你，也就是直接把整个楼都给你搬过去，问题完美解决**。

同时呢，Docker是内核级虚拟化，不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。

总结起来，docker大概就是以下四个优点:

- 更快的应用交付和部署
- 更便捷的升级和扩缩容
- 更简单的系统运维
- 更高效的计算资源利用



实在是太香了。

## 总结：

本篇笔记简单的讲了一下docker的一个基本情况，相信看到这里的小伙伴已经对docker有了一个基本的认识，至少知道docker是什么了，下一篇笔记呢，讲围Docker 三要素 镜像 容器 和仓库这三个概念展开，预知后事如何，点个赞再走吧。

我是韩数，我们下一篇笔记《Docker三要素:镜像，容器和仓库》再见。

PS：更多笔记欢迎大家去我的github上下载(欢迎star)：

<https://github.com/hanshuaikang/HanShu-Note>











